<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Teches on All Time NEET</title>
    <link>https://alltimeneet.com/tech/</link>
    <description>Recent content in Teches on All Time NEET</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 23 Jun 2019 21:49:39 +0900</lastBuildDate>
    
	<atom:link href="https://alltimeneet.com/tech/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>StripeのCheckoutで決済機能を簡単に導入する</title>
      <link>https://alltimeneet.com/tech/stripe-checkout/</link>
      <pubDate>Sun, 23 Jun 2019 21:49:39 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/stripe-checkout/</guid>
      <description>経緯 今までは個人で運営しているスクールなどで発生する毎月の集金にはPaymoBizを利用していました。そんな中PaymoBizサービス終了が発表され、別の集金方法を模索することを余儀なくされてしまいました。「決済APIを利用するという方法が手数料安く済みそうだけど、自前でシステム作るしかないのか・・・手間がかかりそうだなぁ。。」などと思いながら詳しく調べていたところ、StripeではCheckoutという機能が提供されており、その機能を使うと自動生成されたコードを貼り付けるだけで決済機能が導入できるようでした。このシンプルさが自分にはドンピシャだったのですぐに試してみました。
所感 試してみて複雑にデータを管理しなければならないものでなければCheckoutで十分だと感じました。またStripeはただオンライン決済のAPIを提供しているだけの印象でしたが実はそうではなく、ダッシュボードが充実していたりサードパーティ製の決済アプリのマーケトットプレイスとしての側面も持ち合わせていていわゆる「プラットフォーム」という方がしっくりきました。書いた後気付いたのですがPAY.JPが同様の機能を提供していてかつ手数料も1%ほど安いです。
Stripe Checkoutの導入手順メモ 公式ドキュメント
できること  WEBページにJSのスクリプトを貼り付けることで、サーバー側の処理を実装することなく決済機能を導入できます 月額課金にも対応しています カスタマイズ次第で顧客データの収集なども可能  仕様について  実際に使用する際はテストモードと本番モードを切り替える必要があります。最初はテストモードで挙動を確認しておくことをお勧めします。 決済成功時・失敗時の遷移先を用意しておく必要があります。 サイトはhttps化されている必要があります 手数料は一律3.6%(同じく決済APIを提供しているBASE社のPAY.JPは2.6%でした。こちらでも良いかもしれない)  1. アカウントの有効化 導かれるまま本人情報などを入力すればおkです。
2. Checkoutの設定 公式ドキュメント、Checkout Client Quickstartを参考に導入します。主にやることは以下の二つです。
 ドメインの設定 商品の作成とCheckoutの有効化  3. LIVEモードに切り替え Going Live with Checkoutを参考にLIVEモードでチェックアウトできるように設定します。本番モードで稼働する際はドメインが設定されていないとボタンを押しても正しく動作しないので注意。
4. コードの貼り付けとカスタマイズ  テスト 
  var stripe = Stripe(&#39;pk_test_IYYRFH7Xe3g9nygvZkfKsT4I006VEBDP5U&#39;); var checkoutButton = document.getElementById(&#39;checkout-button-plan_FIfczSYPCPZLe1&#39;); checkoutButton.addEventListener(&#39;click&#39;, function () { // When the customer clicks on the button, redirect // them to Checkout.</description>
    </item>
    
    <item>
      <title>GASで任意のTwitterアカウントにDMを送る</title>
      <link>https://alltimeneet.com/tech/gas-twitter-dm/</link>
      <pubDate>Fri, 31 May 2019 01:15:00 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/gas-twitter-dm/</guid>
      <description>前準備 GASからTwitterのアカウントを操作するためには開発者用アカウントの取得などの前準備が必要です。こちらの記事を参考にしてください。
DMする DMのAPIを叩くためには任意のアカウントに紐づくuserIDが必要です。因みにscreenNameとuserIdは違います。screen_nameはメンションするときなどにおなじみの「@」から始まる文字列です。それに対してuserIdは数字だけの文字列です。詳しくはTwitterAPIの公式ドキュメントを参照してください。
今回紹介するgasのスクリプトはscreen_nameからuser_idを取得し、そのuser_id宛にDMを送信するという挙動となっています。
1. screen_nameからuser_idを取得する function getUserId() { var service = twitter.getService(); var screenName = &amp;quot;screen_name&amp;quot; //@screen_nameさんにDMを送る場合 var requestURL = &amp;quot;https://api.twitter.com/1.1/users/lookup.json?screen_name=&amp;quot; + screenName var response = service.fetch(requestURL, { method: &amp;quot;get&amp;quot;, contentType: &#39;application/json&#39; }); var o = JSON.parse(response.getContentText()); var user_id = o[0].id_str //配列で帰ってくるのでそのうちの最初の要素のuser_idを取得する newDirectMessage(user_id) //後述します }  2. user_idに紐づくTwitterアカウント対してDMを送る function newDirectMessage(user_id){ try{ var service = twitter.getService(); var payload = JSON.stringify({ event: { type: &#39;message_create&#39;, message_create: { target: { recipient_id: String(user_id) //先ほど取得したuserId }, message_data: { text: &amp;quot;こんにちは&amp;quot; } //メッセージ内容を定義 } } }); var response = service.</description>
    </item>
    
    <item>
      <title>GASでGoogleカレンダーの予定を週ごとに定期的にツイートするスクリプト</title>
      <link>https://alltimeneet.com/tech/gas-twitter/</link>
      <pubDate>Sun, 05 May 2019 15:41:50 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/gas-twitter/</guid>
      <description>参考  GASで複数のGoogleカレンダーの予定を1週間取得する Google Apps Script (GAS) でTwitterへ投稿するだけの機能を実装してみる Google Apps ScriptでTwitter botを作ってみる  手順 1. アクセストークンとシークレットキーを取得する Google Apps ScriptでTwitter botを作ってみるが圧倒的に詳しく解説されています。丸投げだと身もふたもないので、一応説明します。笑 https://developer.twitter.com/en/appsからcreate an appを選択。 画像引用: Google Apps ScriptでTwitter botを作ってみる
Callback URLs https://script.google.com/macros/d/[GASのスクリプトID]/usercallbackとします。GASのScriptIDはGASエディタのプロパティから調べられます。
登録後  APIKey APISecretKey  上記の二つの値を使用します。「Keys&amp;amp;Tokens」の「ConsumerKey」の欄にあります。
2. GASプロジェクトの作成とTweet用のライブラリを導入する GASプロジェクトの作成方法は割愛します。作成後Twitter用のライブラリをインポートします。「リソース」→「ライブラリ」から以下のプロジェクトキーで追加できます。
1rgo8rXsxi1DxI_5Xgo_t3irTw1Y5cxl2mGSkbozKsSXf2E_KBBPC3xTF
3. Gカレンダーの一週間の予定を取得する ほぼGASで複数のGoogleカレンダーの予定を1週間取得するの通り。for文を用いて一週間それぞれの日付と終日イベントのタイトルの二つを配列として取得し、eventsForWeekにappendしています（最終的には二次配列の形で保存されます）。ちなみにgetDateやgetMonthした値に数字を足して処理しているのは、javascriptのDate型の仕様のため。
参考: JavaScript の Date は罠が多すぎる
function getEventsForWeek() { var calender = CalendarApp.getDefaultCalendar; var dateNow = new Date(); var date = new Date(); var eventsForWeek = []; for (var j = 2; j &amp;lt; 9 ; j++ ){ date.</description>
    </item>
    
    <item>
      <title>RxSwift入門とObservableの概要 まとめ</title>
      <link>https://alltimeneet.com/tech/rxswift-summary/</link>
      <pubDate>Mon, 08 Apr 2019 03:06:17 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/rxswift-summary/</guid>
      <description>RxSwift入門 Observableの概要 まとめ 入門  リアクティブプログラミングとRxJavaの概要 オブザーバーパターンから始めるRxSwift入門  まずは上の記事でリアクティブプログラミングのノリを理解します。特に6pのマーブルダイヤグラムの図が理解に役立ちます。下の記事は実際のコードを交えた解説です。具体的にどのような実装を行えば良いのかがわかります。
Rxができることとそのメリット Rxを使いこなせればありとあらゆるものをストリームとして扱うことが可能です
例えばボタンをタップされた時の挙動はこう書けます。（以下のコードは厳密にはRxSwiftではなくRxCocoaというUIKitをObservableとして扱うことのできるライブラリを用いています。）
import RxCocoa import RxSwift weak var button: UIButton! ~~~~~~~~~~~~~~~~~~ override func viewDidLoad(){ button.rx.tap.subscribe(onNext: { _ in print(&amp;quot;buttonがtapされたよー&amp;quot;) }).disposed(by: DisposeBag()) }  例えばデータのbindや、面倒だった非同期処理を簡単に書けるけるのがメリットです。若干学習コストは高いかなと思いますが、マスターできれば文字通りなんでもできます。
Rxで登場する基本概念 2種 Observable 名前だけでも覚えて帰ってください！！Observableはストリームを流し、そのストーリムをsubscribe(購読)することが可能になります。 Observableが通知するイベントは以下の3種類。subscribe(購読)することで、それぞれのタイミングでクロージャ内のメソッドを呼ぶことが出来る。
･onNext: 通常のイベントが発生した時
･onError: エラーが発生になった時
･onComplete: イベントが完了した時
&amp;mdash; nosugi (@nosugi1) 2019年4月7日 
言い換えると、何かが起こった時の挙動をクロージャの中に記述しておけば何もせんでも勝手に呼んでくれるということです。下のコードは新卒エンジニアの開発日記さんの記事から引用したものになります。趣旨とは外れますが、中の人とは実は学生時代の知り合いだったりします。笑
import RxSwift import RxCococa let observableContentOffset = tableView.rx.contentOffset observableContentOffset .subscribe(onNext: { _ in print(&amp;quot;next&amp;quot;) //スクロールするたびに呼ばれる }, onError: { _ in print(&amp;quot;error&amp;quot;) }, onCompleted: { _ in print(&amp;quot;completed&amp;quot;) }).</description>
    </item>
    
    <item>
      <title>AtomからVSCodeに乗り換えた所感と行なった初期設定</title>
      <link>https://alltimeneet.com/tech/transfer-vscode-from-atom/</link>
      <pubDate>Thu, 04 Apr 2019 12:30:46 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/transfer-vscode-from-atom/</guid>
      <description>メモリ使用量1/4の衝撃 4/3日にVSCodeの新バージョンがリリースされました。TLを眺めていたところ、このようなツイートを発見。 Gighubを買収した成果がこんなところにも。 VSやはり良いですね https://t.co/aJkeMwjOk3
&amp;mdash; Kurose (@jkurose777) 2019年4月3日 
乗るしかない、このビックウェーブに・・・！！ 結論  Atomより圧倒的にVSCode
 Vim職人などの例外を除けば、無料で使えるエディタの中で一番ではないのかなと思います。立ち上がりのはやいAtomという感じ。（強い）
Atomと比較しての所感  とにかく立ち上がりが早い！！・サクサク
Sublimeほどまではいかないが、軽快。 Atomと同等もしくはそれ以上に充実したプラグイン
自分が知らないだけという可能性もありますが、プラグインもatomより優秀な気がする。 洗練されたUI
画面分割やファイル検索など自在にできる。特にGitがみやすい。  初期設定など UI設定  フォントサイズの設定
デフォルトは12で少しみにくいので15 テーマ
Visual Studio Codeで見やすいテーマファイルのまとめから自分はAtomOneDarkを選びました。  ファイル自動保存 デフォルトではオフになっていて使いにくいので、onFocusChange(フォーカスを外した際に保存される)に変更。 
自動コード整形 設定画面の検索窓から「formaton」で検索。「Format On Type」にチェック
標準ターミナルではなくiTermを使えるように設定 VSCode内でiTermを使いたいので以下のように設定します。 「UserSettings」→「Features」→「Extension Viewlet」 
ちなみにMacではControl+Shift+@でterminalを起動できます。
プラグイン VSCodeのオススメ拡張機能 24 選 (とTipsをいくつか)から気に入ったものをインストールしました。他にもあれば教えて欲しいです。
デバッグ Webの開発行う人は入れておくとよいかと思います。 - Debugger for Chrome - Live Server
参考: Visual Studio Code でフロントエンドの開発環境を構築してデバッグする
ターミナルからファイルやプロジェクトをVSCodeで開く code .</description>
    </item>
    
    <item>
      <title>GAS(GoogleAppsScript)とTypeScriptを使って簡単なLinebotを作る</title>
      <link>https://alltimeneet.com/tech/gas-linebot/</link>
      <pubDate>Thu, 04 Apr 2019 04:08:49 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/gas-linebot/</guid>
      <description>（GASのアプリケーションが正しく公開されていなかったりBotの設定がわからなかったりして普通に時間かかりました。Qiitaで30分でできたとか書いてる人いるけど絶対嘘だろ！！）
使うもの  GAS clasp TypeScript  ローカル開発環境の構築 補完とか使えるので個人的にはローカルで開発することをお勧めします。もちろんGASのエディタを使っても良いです。まずはhttps://script.google.com/home/usersettingsからGoogleAppsScriptAPIをオンにしておきます。 
プロジェクト作成 mkdir gas-project //プロジェクトファイル作成 cd gas-project npm init -y npm i -S @google/clasp //claspについては後述 npm i -S @types/google-apps-script @types/node clasp create --title &amp;quot;GcarenderBot&amp;quot; --rootDir ./src clasp pull  説明することが2つあるので軽く触れます。
1. clasp 以下のようにGoogle製のCIライブラリであるclaspを使うことでプロジェクトファイルをgitみたいな感じで扱うことができます。clasp createでGASにプロジェクトが登録されます。その際&amp;ndash;rootDirオプションでディレクトリを指定しましょう。
clasp create --title &amp;quot;gas-project&amp;quot; --rootDir ./src clasp pull //GASからpull clasp push //GASにpush  2. Typescriptへの対応 npm i -S @types/google-apps-script @types/node  地味に嬉しい人多いのでは??clasp pushすれば*.tsから*.jsへコンパイルはGASが勝手にやってくれます。強い。
実装 ローカル開発環境を整えたところで、簡単な実装します。試しにおうむ返しするBotを作ります。LineBotでできることと仕様についてはLineMessagingAPIリファレンスをチェケラ
コード コードは下記のリンクから拝借したしたものです。ファイル名は適当にcode.</description>
    </item>
    
    <item>
      <title>AVFoundation覚書 iOSアプリでバーコードリーダーを実装する</title>
      <link>https://alltimeneet.com/tech/ios-camera-avfoundation/</link>
      <pubDate>Wed, 03 Apr 2019 01:50:01 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/ios-camera-avfoundation/</guid>
      <description> 挙動  読み取ったバーコードの値でGoogleBooksAPIを叩いて本のタイトル、作者などの情報を取得する。
 参考URL  iOSでバーコードを読み取る AVFoundation(AVCaptureMetadataOutput)でバーコードリーダーを作ってみた  実装 事前準備 この手順を踏まずにカメラを起動しようとすると強制終了するので注意！。XcodeのInfo.plistにPrivacy - Camera Usage Descriptionを追加します。カメラを使用する目的を値として入力します。 
 参考: iOS10ではカメラアクセスなどの目的を明示しないと強制終了する  AVCaptureMetadataOutputObjectsDelegate </description>
    </item>
    
    <item>
      <title>RxSwiftでUITableViewの実装</title>
      <link>https://alltimeneet.com/tech/rxswift-uitableview/</link>
      <pubDate>Wed, 03 Apr 2019 00:46:56 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/rxswift-uitableview/</guid>
      <description>鬼門でした。
RxSwiftを使ったUITableViewの実装 大きく分けてふたパターンあります。UITableViewDataSourceで実装する部分をRxを用いて実装します。1のやり方はシンプルです。2は自由度が高い実装が可能です。
  ObservableをUITableViewにbindして実装 DataSourceを自分で定義して実装   1. ObservableをUITableViewにbindして実装 A. デフォルトのセルを使う場合 indexPath.rowとitems[n]、cellを引数に取ります。
let items: Observable&amp;lt;[Item]&amp;gt; = ... items .bind(to: tableView.rx.items(cellIdentifier: &amp;quot;Cell&amp;quot;)) { row, element, cell in // row: Int …… アイテムのインデックス // element: Item …… アイテムのインスタンス // cell: UITableViewCell …… セルのインスタンス // ここでセルの中身を設定する cell.textLabel?.text = element.name } .disposed(by: disposeBag)  B. カスタムセルを使う場合 Aパターンの実装に加えてcelltypeを指定できるようになりました。カスタムセルを使う場合はこちらを使います。
let items: Observable&amp;lt;[Item]&amp;gt; = ... items .bind(to: tableView.rx.items(cellIdentifier: &amp;quot;Cell&amp;quot;, cellType: MyTableViewCell.self)) { row, element, cell in // row: Int …… アイテムのインデックス // element: Item …… アイテムのインスタンス // cell: MyTableViewCell …… セルのインスタンス // ここでセルの中身を設定する cell.</description>
    </item>
    
    <item>
      <title>Firebaseでサーバーレス開発  ログイン編(iOS版)</title>
      <link>https://alltimeneet.com/tech/firebase-auth-ios/</link>
      <pubDate>Sun, 31 Mar 2019 09:48:36 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/firebase-auth-ios/</guid>
      <description>参考URL 基本的には公式ドキュメントを参考にしましたが端折られている部分もあったので、こちらのQiitaの記事も合わせて参考にしました。
導入 cocoapodsでインストールします。cocoapodsの使い方については割愛します。そのあとは下の画像のような感じでかなり親切にやってくれます、簡単に導入できました。 
共通部分 AppDelegateに追記。公式ドキュメントに従ってdidFinishLaunchingWithOptionsに書くとエラーになるので注意。尚、このことは公式ドキュメントでは言及されていない。
import Firebase import FirebaseAuthUI class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? //以下追記 override init() { super.init() FirebaseApp.configure() } func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any]) -&amp;gt; Bool { let sourceApplication = options[UIApplication.OpenURLOptionsKey.sourceApplication] as! String? if FUIAuth.defaultAuthUI()?.handleOpen(url, sourceApplication: sourceApplication) ?? false { return true } // other URL handling goes here. return false }  ツイッターログイン 1. Twitterログインの有効化 developer.</description>
    </item>
    
    <item>
      <title>SoracomAPIを試してみる</title>
      <link>https://alltimeneet.com/tech/try-soracom-api/</link>
      <pubDate>Sun, 17 Feb 2019 15:06:08 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/try-soracom-api/</guid>
      <description>SoracomAirのSimを触ってみる SoracomSimの登録 soracomコンソールから登録できます 
料金体系 公式サイト 
APIを叩いてみる 1.APIキーとトークンの取得  リクエストURL  https://api.soracom.io/v1/auth  クエリ  email: メールアドレス password: パスワード  レスポンス
{ &amp;quot;apiKey&amp;quot;: &amp;quot;APIKEY&amp;quot;, &amp;quot;operatorId&amp;quot;: &amp;quot;OPERATORID&amp;quot;, &amp;quot;userName&amp;quot;: null, &amp;quot;token&amp;quot;: &amp;quot;TOKEN&amp;quot; }   一応WEBからも発行可能です。こちらのリンクから二種類あるので好きなやり方で認証・発行してください。 
2.APIを叩いてみる 試しに登録したSimカードの一覧を取得するAPIを叩いてみます。
 リクエストURL  https://api.soracom.io/v1/subscribers  リクエストヘッダ 先ほど取得したapiKeyとTokenを使用します  X-Soracom-API-Key=APIKEY X-Soracom-Token=TOKEN  レスポンス
[ { &amp;quot;imsi&amp;quot;: &amp;quot;440103198207751&amp;quot;, &amp;quot;msisdn&amp;quot;: &amp;quot;812016084496&amp;quot;, &amp;quot;ipAddress&amp;quot;: &amp;quot;10.245.237.68&amp;quot;, &amp;quot;operatorId&amp;quot;: &amp;quot;OP0061660828&amp;quot;, &amp;quot;apn&amp;quot;: &amp;quot;soracom.io&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;s1.standard&amp;quot;, &amp;quot;groupId&amp;quot;: null, &amp;quot;createdAt&amp;quot;: 1545836470247, &amp;quot;lastModifiedAt&amp;quot;: 1550380631731, &amp;quot;expiredAt&amp;quot;: null, &amp;quot;registeredTime&amp;quot;: 1549618116968, &amp;quot;expiryAction&amp;quot;: null, &amp;quot;terminationEnabled&amp;quot;: false, &amp;quot;status&amp;quot;: &amp;quot;active&amp;quot;, &amp;quot;tags&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;mySim&amp;quot; }, &amp;quot;sessionStatus&amp;quot;: { &amp;quot;lastUpdatedAt&amp;quot;: 1550380631731, &amp;quot;imei&amp;quot;: &amp;quot;353168044272803&amp;quot;, &amp;quot;location&amp;quot;: null, &amp;quot;cell&amp;quot;: { &amp;quot;radioType&amp;quot;: &amp;quot;lte&amp;quot;, &amp;quot;mcc&amp;quot;: 440, &amp;quot;mnc&amp;quot;: 10, &amp;quot;tac&amp;quot;: 12390, &amp;quot;eci&amp;quot;: 185881861 }, &amp;quot;ueIpAddress&amp;quot;: &amp;quot;10.</description>
    </item>
    
    <item>
      <title>CircleCIで毎回面倒なHugoのデプロイ作業を自動化する</title>
      <link>https://alltimeneet.com/tech/circleci-hugo/</link>
      <pubDate>Tue, 12 Feb 2019 22:03:25 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/circleci-hugo/</guid>
      <description>CIサービスとは  ビルドとテストを自動化するためのサービス
 ということで理解しておけばいいと思います。一応直訳すると「Continuous Integration（継続的インテグレーションサービス）」、略してCIサービスということらしいです。
参考: なぜCIが必要なのか
目標  GithubPagesで公開しているHugoプロジェクトのデプロイ作業を自動化する
 Hugoの場合はプロジェクト本体ではなく、publicディレクトリ以下をgithubにホスティングする必要があるので、デプロイするときは基本的に以下のような手順を踏まなければならない。
$ git commit -m &amp;quot;hoge&amp;quot; $ hugo #public以下にサイトを生成するコマンド $ cd public $ git commit -m &amp;quot;hogehoge&amp;quot; $ git push  このルーティンが段々だるくなってくきたので、CircleCiでこれを自動化する。
手順  レポジトリとデプロイキーを登録する .circleci/config.ymlの記述  参考: CircleCIでHugoを実行してGitHub Pagesにデプロイ
ブログ(HUGO)のビルドとデプロイをCircleCIで自動化した
1. レポジトリとデプロイキーを登録する  レポジトリの登録
最初のブランチ一覧が表示される画面で登録したいレポジトリにチェックマークをつけてFollowを押せば登録できます。 デプロイキーの登録
今回はgithubへのsshキーを登録します。サイドメニューのcheck out SSH Key からadd User KeyでGithubアカウントにログインすること楽に登録ができます。手動で登録も可能ですが、pushのための書き込み権限の付与がされてなくてエラーになりました、何やかんややりましたが解決できなかったので、check out ssh keyからの登録をお勧めします。  2. .circleci/config.ymlの記述 CircleCiにやってほしいことを.circleci/config.ymlに記述します。githubのレポジトリにpushされた時発火します。 僕の場合masterブランチでhugoプロジェクト本体、gh-pagesブランチで公開用のpublic以下のファイル群を管理しています。内容はこんな感じです参考までに
version: 2 jobs: build: docker: - image: cibuilds/hugo:latest environment: TZ: Asia/Tokyo #ここら辺はコピペでいいと思う branches: ignore: - gh-pages #gh-pagesにプッシュされた際に反応しないようにignoreを設定している steps: - checkout - run: name: &amp;quot;Setting for Git&amp;quot; command: | git config --global user.</description>
    </item>
    
    <item>
      <title>ブログをJekyllからHugoへ移行した</title>
      <link>https://alltimeneet.com/tech/hugo-import-jekyll/</link>
      <pubDate>Tue, 12 Feb 2019 22:01:43 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/hugo-import-jekyll/</guid>
      <description>データをJekyllからインポート なんとHugoがコマンドを用意してくれています。一発で綺麗に引越し完了！とはなりませんが、楽チン。
$ hugo imoprt jekyll path_to_jekyll_root_project path_to_hugo_root_project  日付のデータは、移行できないようです。なぜか記事ファイルのメタデータが無視されていたので、手動でコピーし直しました。 終了すると、Hugoから
$ git clone https://github.com/spf13/herring-cove.git HOGEHOGE/themes/herring-cove $ hugo server --theme=herring-cove  「このコマンド打ってな〜」と言われると思いますが、なんとその通りにやってもうまくいきません！笑 git cloneしたherring-coveテーマが原因です。おそらくアプデされていないのでしょう。以下のように直します。変更箇所は複数のファイルで存在するので、エディタの機能使うなどして一括変換するといいと思います。
 {{ template &amp;ldquo;theme/herring-cove/footer.html&amp;rdquo; . }} を {{ partial &amp;ldquo;footer.html&amp;rdquo; }}に {{ template &amp;ldquo;theme/herring-cove/header.html&amp;rdquo; . }} を {{ partial &amp;ldquo;header.html&amp;rdquo; }}に  これで再度hugo serverすると動いてくれるかなと思います。正常に動くのを確認したら、あとは適当に良さげなテーマ選んでやればおkです！
終わりに 日付のデータを移行できなかったのが残念ですね。。それ以外は簡単に移行できたので、まぁ良しとします！
「ブログを書く→git commit→git push」という手順を踏むのが面倒になってきたので 次回は流行り？のCIサービス、CircleCIの無料枠を使ってデプロイの自動化を行いたいと思います。こちらもこのブログで手順や所感をメモしておこうとお思います。</description>
    </item>
    
    <item>
      <title>Hugo覚書とその所感</title>
      <link>https://alltimeneet.com/tech/2019-01-20-programming-hugo/</link>
      <pubDate>Sun, 20 Jan 2019 09:03:48 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/2019-01-20-programming-hugo/</guid>
      <description>ざっくりHugoについて Go製の静的webジェネレータ。新しいライブラリというかフレームワーク？？なので、コミュニティもJekyllに比べて盛んな印象です。
インストール $ brew install hugo $ hugo version  brew以外のインストール方法もあるようです。 参考: install Hugo
使い方 コマンド  プロジェクト作成
$ hugo new site yoursite  ローカルサーバーを立てる
$ hugo server  post
$ hugo new post/first-post.md   /content以下に作成される仕様になっております。 - テーマの適用
$ git clone hoge@hoge.git themes/hoge #テーマ「hoge」をclone $ echo &#39;theme = &amp;quot;hoge&amp;quot;&#39; &amp;gt;&amp;gt; config.toml #config.tomlへ記述  設定などはconfig.tomlへ記述するようです。どうでもいいけど、toml形式って初めて見ました。 こちらの公式ドキュメントが参考になると思います quickstart
HugoでGithubPagesにホスティング $ hugo  でpublicディレクトリが追加される。 このpublicディレクトリ以下をGithubPagesでホスティングします。プロジェクトディレクトリではありません、注意！
やっておくと良いこと  絶対パス化
$ echo &#39;canonifyurls = true&#39; &amp;gt;&amp;gt; config.</description>
    </item>
    
  </channel>
</rss>