<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技術 on All Time NEET</title>
    <link>https://alltimeneet.com/category/%E6%8A%80%E8%A1%93/</link>
    <description>Recent content in 技術 on All Time NEET</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 23 Jun 2019 21:49:39 +0900</lastBuildDate>
    
	<atom:link href="https://alltimeneet.com/category/%E6%8A%80%E8%A1%93/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>StripeのCheckoutで決済機能を簡単に導入する</title>
      <link>https://alltimeneet.com/tech/stripe-checkout/</link>
      <pubDate>Sun, 23 Jun 2019 21:49:39 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/stripe-checkout/</guid>
      <description>経緯 今までは個人で運営しているスクールなどで発生する毎月の集金にはPaymoBizを利用していました。そんな中PaymoBizサービス終了が発表され、別の集金方法を模索することを余儀なくされてしまいました。「決済APIを利用するという方法が手数料安く済みそうだけど、自前でシステム作るしかないのか・・・手間がかかりそうだなぁ。。」などと思いながら詳しく調べていたところ、StripeではCheckoutという機能が提供されており、その機能を使うと自動生成されたコードを貼り付けるだけで決済機能が導入できるようでした。このシンプルさが自分にはドンピシャだったのですぐに試してみました。
所感 試してみて複雑にデータを管理しなければならないものでなければCheckoutで十分だと感じました。またStripeはただオンライン決済のAPIを提供しているだけの印象でしたが実はそうではなく、ダッシュボードが充実していたりサードパーティ製の決済アプリのマーケトットプレイスとしての側面も持ち合わせていていわゆる「プラットフォーム」という方がしっくりきました。書いた後気付いたのですがPAY.JPが同様の機能を提供していてかつ手数料も1%ほど安いです。
Stripe Checkoutの導入手順メモ 公式ドキュメント
できること  WEBページにJSのスクリプトを貼り付けることで、サーバー側の処理を実装することなく決済機能を導入できます 月額課金にも対応しています カスタマイズ次第で顧客データの収集なども可能  仕様について  実際に使用する際はテストモードと本番モードを切り替える必要があります。最初はテストモードで挙動を確認しておくことをお勧めします。 決済成功時・失敗時の遷移先を用意しておく必要があります。 サイトはhttps化されている必要があります 手数料は一律3.6%(同じく決済APIを提供しているBASE社のPAY.JPは2.6%でした。こちらでも良いかもしれない)  1. アカウントの有効化 導かれるまま本人情報などを入力すればおkです。
2. Checkoutの設定 公式ドキュメント、Checkout Client Quickstartを参考に導入します。主にやることは以下の二つです。
 ドメインの設定 商品の作成とCheckoutの有効化  3. LIVEモードに切り替え Going Live with Checkoutを参考にLIVEモードでチェックアウトできるように設定します。本番モードで稼働する際はドメインが設定されていないとボタンを押しても正しく動作しないので注意。
4. コードの貼り付けとカスタマイズ &amp;lt;button style=&amp;quot;background-color:#6772E5;color:#FFF;padding:8px 12px;border:0;border-radius:4px;font-size:1em&amp;rdquo; id=&amp;quot;checkout-button-plan_FIfczSYPCPZLe1&amp;rdquo; role=&amp;quot;link&amp;rdquo;
  テスト 上のボタンを押すとクレジットカード情報の入力フォームにリダイレクトされるはずです。中身のコードは以下に掲載しています。見た目や顧客データの処理についてのカスタマイズも可能です。詳しくは公式ドキュメントを参照してください。
&amp;lt;script src=&amp;#34;https://js.stripe.com/v3&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- Create a button that your customers click to complete their purchase. Customize the styling to suit your branding. --&amp;gt; &amp;lt;button style=&amp;#34;background-color:#6772E5;color:#FFF;padding:8px 12px;border:0;border-radius:4px;font-size:1em&amp;#34; id=&amp;#34;checkout-button-plan_FIfczSYPCPZLe1&amp;#34; role=&amp;#34;link&amp;#34; &amp;gt; テスト &amp;lt;/button&amp;gt; &amp;lt;div id=&amp;#34;error-message&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; // 本番はLIVEモードのAPIキーを入力してください  var stripe = Stripe(&amp;#39;pk_test_IYYRFH7Xe3g9nygvZkfKsT4I006VEBDP5U&amp;#39;); var checkoutButton = document.</description>
    </item>
    
    <item>
      <title>GASで任意のTwitterアカウントにDMを送る</title>
      <link>https://alltimeneet.com/tech/gas-twitter-dm/</link>
      <pubDate>Fri, 31 May 2019 01:15:00 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/gas-twitter-dm/</guid>
      <description>前準備 GASからTwitterのアカウントを操作するためには開発者用アカウントの取得などの前準備が必要です。こちらの記事を参考にしてください。
DMする DMのAPIを叩くためには任意のアカウントに紐づくuserIDが必要です。因みにscreenNameとuserIdは違います。screen_nameはメンションするときなどにおなじみの「@」から始まる文字列です。それに対してuserIdは数字だけの文字列です。詳しくはTwitterAPIの公式ドキュメントを参照してください。
今回紹介するgasのスクリプトはscreen_nameからuser_idを取得し、そのuser_id宛にDMを送信するという挙動となっています。
1. screen_nameからuser_idを取得する function getUserId() { var service = twitter.getService(); var screenName = &amp;#34;screen_name&amp;#34; //@screen_nameさんにDMを送る場合  var requestURL = &amp;#34;https://api.twitter.com/1.1/users/lookup.json?screen_name=&amp;#34; + screenName var response = service.fetch(requestURL, { method: &amp;#34;get&amp;#34;, contentType: &amp;#39;application/json&amp;#39; }); var o = JSON.parse(response.getContentText()); var user_id = o[0].id_str //配列で帰ってくるのでそのうちの最初の要素のuser_idを取得する  newDirectMessage(user_id) //後述します } 2. user_idに紐づくTwitterアカウント対してDMを送る function newDirectMessage(user_id){ try{ var service = twitter.getService(); var payload = JSON.stringify({ event: { type: &amp;#39;message_create&amp;#39;, message_create: { target: { recipient_id: String(user_id) //先ほど取得したuserId  }, message_data: { text: &amp;#34;こんにちは&amp;#34; } //メッセージ内容を定義  } } }); var response = service.</description>
    </item>
    
    <item>
      <title>GASでGoogleカレンダーの予定を週ごとに定期的にツイートするスクリプト</title>
      <link>https://alltimeneet.com/tech/gas-twitter/</link>
      <pubDate>Sun, 05 May 2019 15:41:50 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/gas-twitter/</guid>
      <description>参考  GASで複数のGoogleカレンダーの予定を1週間取得する Google Apps Script (GAS) でTwitterへ投稿するだけの機能を実装してみる Google Apps ScriptでTwitter botを作ってみる  手順 1. アクセストークンとシークレットキーを取得する Google Apps ScriptでTwitter botを作ってみるが圧倒的に詳しく解説されています。丸投げだと身もふたもないので、一応説明します。笑 https://developer.twitter.com/en/appsからcreate an appを選択。 画像引用: Google Apps ScriptでTwitter botを作ってみる
Callback URLs https://script.google.com/macros/d/[GASのスクリプトID]/usercallbackとします。GASのScriptIDはGASエディタのプロパティから調べられます。
登録後  APIKey APISecretKey  上記の二つの値を使用します。「Keys&amp;amp;Tokens」の「ConsumerKey」の欄にあります。
2. GASプロジェクトの作成とTweet用のライブラリを導入する GASプロジェクトの作成方法は割愛します。作成後Twitter用のライブラリをインポートします。「リソース」→「ライブラリ」から以下のプロジェクトキーで追加できます。
1rgo8rXsxi1DxI_5Xgo_t3irTw1Y5cxl2mGSkbozKsSXf2E_KBBPC3xTF
3. Gカレンダーの一週間の予定を取得する ほぼGASで複数のGoogleカレンダーの予定を1週間取得するの通り。for文を用いて一週間それぞれの日付と終日イベントのタイトルの二つを配列として取得し、eventsForWeekにappendしています（最終的には二次配列の形で保存されます）。ちなみにgetDateやgetMonthした値に数字を足して処理しているのは、javascriptのDate型の仕様のため。
参考: JavaScript の Date は罠が多すぎる
function getEventsForWeek() { var calender = CalendarApp.getDefaultCalendar; var dateNow = new Date(); var date = new Date(); var eventsForWeek = []; for (var j = 2; j &amp;lt; 9 ; j++ ){ date.</description>
    </item>
    
    <item>
      <title>RxSwift入門とObservableの概要 まとめ</title>
      <link>https://alltimeneet.com/tech/rxswift-summary/</link>
      <pubDate>Mon, 08 Apr 2019 03:06:17 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/rxswift-summary/</guid>
      <description>RxSwift入門 Observableの概要 まとめ 入門  リアクティブプログラミングとRxJavaの概要 オブザーバーパターンから始めるRxSwift入門  まずは上の記事でリアクティブプログラミングのノリを理解します。特に6pのマーブルダイヤグラムの図が理解に役立ちます。下の記事は実際のコードを交えた解説です。具体的にどのような実装を行えば良いのかがわかります。
Rxができることとそのメリット Rxを使いこなせればありとあらゆるものをストリームとして扱うことが可能です
例えばボタンをタップされた時の挙動はこう書けます。（以下のコードは厳密にはRxSwiftではなくRxCocoaというUIKitをObservableとして扱うことのできるライブラリを用いています。）
import RxCocoa import RxSwift weak var button: UIButton! ~~~~~~~~~~~~~~~~~~ override func viewDidLoad(){ button.rx.tap.subscribe(onNext: { _ in print(&amp;#34;buttonがtapされたよー&amp;#34;) }).disposed(by: DisposeBag()) } 例えばデータのbindや、面倒だった非同期処理を簡単に書けるけるのがメリットです。若干学習コストは高いかなと思いますが、マスターできれば文字通りなんでもできます。
Rxで登場する基本概念 2種 Observable 名前だけでも覚えて帰ってください！！Observableはストリームを流し、そのストーリムをsubscribe(購読)することが可能になります。
言い換えると、何かが起こった時の挙動をクロージャの中に記述しておけば何もせんでも勝手に呼んでくれるということです。下のコードは新卒エンジニアの開発日記さんの記事から引用したものになります。趣旨とは外れますが、中の人とは実は学生時代の知り合いだったりします。笑
import RxSwift import RxCococa let observableContentOffset = tableView.rx.contentOffset observableContentOffset .subscribe(onNext: { _ in print(&amp;#34;next&amp;#34;) //スクロールするたびに呼ばれる }, onError: { _ in print(&amp;#34;error&amp;#34;) }, onCompleted: { _ in print(&amp;#34;completed&amp;#34;) }).disposed(by: DisposeBag()) Disposable }.disposed(by: DisposeBag()) について疑問を持った方も多いと思います。これについて説明します。こう書くことによって購読を解除できます。購読し続けるとその分メモリを圧迫し、アプリのパフォーマンスに影響するので基本的にはメソッドが走った最後に購読を解除します。今まで特に理解せずにこのメソッドを使っていましたが、オブザーバーパターンから始めるRxSwift入門 から引用するとどうやら</description>
    </item>
    
    <item>
      <title>AtomからVSCodeに乗り換えた所感と行なった初期設定</title>
      <link>https://alltimeneet.com/tech/transfer-vscode-from-atom/</link>
      <pubDate>Thu, 04 Apr 2019 12:30:46 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/transfer-vscode-from-atom/</guid>
      <description>メモリ使用量1/4の衝撃 4/3日にVSCodeの新バージョンがリリースされました。TLを眺めていたところ、このようなツイートを発見。
乗るしかない、このビックウェーブに・・・！！ 結論  Atomより圧倒的にVSCode
 Vim職人などの例外を除けば、無料で使えるエディタの中で一番ではないのかなと思います。立ち上がりのはやいAtomという感じ。（強い）
Atomと比較しての所感  とにかく立ち上がりが早い！！・サクサク
Sublimeほどまではいかないが、軽快。 Atomと同等もしくはそれ以上に充実したプラグイン
自分が知らないだけという可能性もありますが、プラグインもatomより優秀な気がする。 洗練されたUI
画面分割やファイル検索など自在にできる。特にGitがみやすい。  初期設定など UI設定  フォントサイズの設定
デフォルトは12で少しみにくいので15 テーマ
Visual Studio Codeで見やすいテーマファイルのまとめから自分はAtomOneDarkを選びました。  ファイル自動保存 デフォルトではオフになっていて使いにくいので、onFocusChange(フォーカスを外した際に保存される)に変更。 
自動コード整形 設定画面の検索窓から「formaton」で検索。「Format On Type」にチェック
標準ターミナルではなくiTermを使えるように設定 VSCode内でiTermを使いたいので以下のように設定します。 「UserSettings」→「Features」→「Extension Viewlet」 
ちなみにMacではControl+Shift+@でterminalを起動できます。
プラグイン VSCodeのオススメ拡張機能 24 選 (とTipsをいくつか)から気に入ったものをインストールしました。他にもあれば教えて欲しいです。
デバッグ Webの開発行う人は入れておくとよいかと思います。
 Debugger for Chrome Live Server  参考: Visual Studio Code でフロントエンドの開発環境を構築してデバッグする
ターミナルからファイルやプロジェクトをVSCodeで開く code . code filename で開けるように設定。ターミナルからVisual Studio Codeを起動する方法【公式の方法】の通りです。
最後に さようならAtom。</description>
    </item>
    
    <item>
      <title>GAS(GoogleAppsScript)とTypeScriptを使って簡単なLinebotを作る</title>
      <link>https://alltimeneet.com/tech/gas-linebot/</link>
      <pubDate>Thu, 04 Apr 2019 04:08:49 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/gas-linebot/</guid>
      <description>（GASのアプリケーションが正しく公開されていなかったりBotの設定がわからなかったりして普通に時間かかりました。Qiitaで30分でできたとか書いてる人いるけど絶対嘘だろ！！）
使うもの  GAS clasp TypeScript  ローカル開発環境の構築 補完とか使えるので個人的にはローカルで開発することをお勧めします。もちろんGASのエディタを使っても良いです。まずはhttps://script.google.com/home/usersettingsからGoogleAppsScriptAPIをオンにしておきます。 
プロジェクト作成 mkdir gas-project //プロジェクトファイル作成 cd gas-project npm init -y npm i -S @google/clasp //claspについては後述 npm i -S @types/google-apps-script @types/node clasp create --title &amp;#34;GcarenderBot&amp;#34; --rootDir ./src clasp pull 説明することが2つあるので軽く触れます。
1. clasp 以下のようにGoogle製のCIライブラリであるclaspを使うことでプロジェクトファイルをgitみたいな感じで扱うことができます。clasp createでGASにプロジェクトが登録されます。その際&amp;ndash;rootDirオプションでディレクトリを指定しましょう。
clasp create --title &amp;#34;gas-project&amp;#34; --rootDir ./src clasp pull //GASからpull clasp push //GASにpush 2. Typescriptへの対応 npm i -S @types/google-apps-script @types/node 地味に嬉しい人多いのでは??clasp pushすれば*.tsから*.jsへコンパイルはGASが勝手にやってくれます。強い。
実装 ローカル開発環境を整えたところで、簡単な実装します。試しにおうむ返しするBotを作ります。LineBotでできることと仕様についてはLineMessagingAPIリファレンスをチェケラ
コード コードは下記のリンクから拝借したしたものです。ファイル名は適当にcode.tsとかで良いと思います。
 【LINE Botの作り方】Messaging API × GAS(Google Apps Script)でおうむ返しボットを作成する  var channel_access_token = &amp;#34;各自取得&amp;#34; function doPost(e) { var events = JSON.</description>
    </item>
    
    <item>
      <title>AVFoundation覚書 iOSアプリでバーコードリーダーを実装する</title>
      <link>https://alltimeneet.com/tech/ios-camera-avfoundation/</link>
      <pubDate>Wed, 03 Apr 2019 01:50:01 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/ios-camera-avfoundation/</guid>
      <description>挙動  読み取ったバーコードの値でGoogleBooksAPIを叩いて本のタイトル、作者などの情報を取得する。
 参考URL  iOSでバーコードを読み取る AVFoundation(AVCaptureMetadataOutput)でバーコードリーダーを作ってみた  実装 事前準備 この手順を踏まずにカメラを起動しようとすると強制終了するので注意！。XcodeのInfo.plistにPrivacy - Camera Usage Descriptionを追加します。カメラを使用する目的を値として入力します。 
 参考: iOS10ではカメラアクセスなどの目的を明示しないと強制終了する  AVCaptureMetadataOutputObjectsDelegate </description>
    </item>
    
    <item>
      <title>RxSwiftでUITableViewの実装</title>
      <link>https://alltimeneet.com/tech/rxswift-uitableview/</link>
      <pubDate>Wed, 03 Apr 2019 00:46:56 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/rxswift-uitableview/</guid>
      <description>鬼門でした。
RxSwiftを使ったUITableViewの実装 大きく分けてふたパターンあります。UITableViewDataSourceで実装する部分をRxを用いて実装します。1のやり方はシンプルです。2は自由度が高い実装が可能です。
  ObservableをUITableViewにbindして実装 DataSourceを自分で定義して実装   1. ObservableをUITableViewにbindして実装 A. デフォルトのセルを使う場合 indexPath.rowとitems[n]、cellを引数に取ります。
let items: Observable&amp;lt;[Item]&amp;gt; = ... items .bind(to: tableView.rx.items(cellIdentifier: &amp;#34;Cell&amp;#34;)) { row, element, cell in // row: Int …… アイテムのインデックス // element: Item …… アイテムのインスタンス // cell: UITableViewCell …… セルのインスタンス // ここでセルの中身を設定する cell.textLabel?.text = element.name } .disposed(by: disposeBag) B. カスタムセルを使う場合 Aパターンの実装に加えてcelltypeを指定できるようになりました。カスタムセルを使う場合はこちらを使います。
let items: Observable&amp;lt;[Item]&amp;gt; = ... items .bind(to: tableView.rx.items(cellIdentifier: &amp;#34;Cell&amp;#34;, cellType: MyTableViewCell.self)) { row, element, cell in // row: Int …… アイテムのインデックス // element: Item …… アイテムのインスタンス // cell: MyTableViewCell …… セルのインスタンス // ここでセルの中身を設定する cell.</description>
    </item>
    
    <item>
      <title>Firebaseでサーバーレス開発  ログイン編(iOS版)</title>
      <link>https://alltimeneet.com/tech/firebase-auth-ios/</link>
      <pubDate>Sun, 31 Mar 2019 09:48:36 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/firebase-auth-ios/</guid>
      <description>参考URL 基本的には公式ドキュメントを参考にしましたが端折られている部分もあったので、こちらのQiitaの記事も合わせて参考にしました。
導入 cocoapodsでインストールします。cocoapodsの使い方については割愛します。そのあとは下の画像のような感じでかなり親切にやってくれます、簡単に導入できました。 
共通部分 AppDelegateに追記。公式ドキュメントに従ってdidFinishLaunchingWithOptionsに書くとエラーになるので注意。尚、このことは公式ドキュメントでは言及されていない。
import Firebase import FirebaseAuthUI class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? //以下追記 override init() { super.init() FirebaseApp.configure() } func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any]) -&amp;gt; Bool { let sourceApplication = options[UIApplication.OpenURLOptionsKey.sourceApplication] as! String? if FUIAuth.defaultAuthUI()?.handleOpen(url, sourceApplication: sourceApplication) ?? false { return true } // other URL handling goes here. return false } ツイッターログイン 1. Twitterログインの有効化 developer.twitter.comからapiKeyとTokenを取得する必要があります。使用用途などについて300文字くらい書かされてクッソめんどかったです。まぁ無料で使わせてもらってるので大人しく感謝します。先ほどのリンクからアプリを登録したあと、FirebaseAuthのコンソールからそれぞれのキーを登録・有効化しましょう。</description>
    </item>
    
    <item>
      <title>SoracomAPIを試してみる</title>
      <link>https://alltimeneet.com/tech/try-soracom-api/</link>
      <pubDate>Sun, 17 Feb 2019 15:06:08 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/try-soracom-api/</guid>
      <description>SoracomAirのSimを触ってみる SoracomSimの登録 soracomコンソールから登録できます 
料金体系 公式サイト 
APIを叩いてみる 1.APIキーとトークンの取得  リクエストURL  https://api.soracom.io/v1/auth   クエリ  email: メールアドレス password: パスワード   レスポンス  { &amp;#34;apiKey&amp;#34;: &amp;#34;APIKEY&amp;#34;, &amp;#34;operatorId&amp;#34;: &amp;#34;OPERATORID&amp;#34;, &amp;#34;userName&amp;#34;: null, &amp;#34;token&amp;#34;: &amp;#34;TOKEN&amp;#34; } 一応WEBからも発行可能です。こちらのリンクから二種類あるので好きなやり方で認証・発行してください。 
2.APIを叩いてみる 試しに登録したSimカードの一覧を取得するAPIを叩いてみます。
 リクエストURL  https://api.soracom.io/v1/subscribers   リクエストヘッダ 先ほど取得したapiKeyとTokenを使用します  X-Soracom-API-Key=APIKEY X-Soracom-Token=TOKEN   レスポンス  [ { &amp;#34;imsi&amp;#34;: &amp;#34;440103198207751&amp;#34;, &amp;#34;msisdn&amp;#34;: &amp;#34;812016084496&amp;#34;, &amp;#34;ipAddress&amp;#34;: &amp;#34;10.245.237.68&amp;#34;, &amp;#34;operatorId&amp;#34;: &amp;#34;OP0061660828&amp;#34;, &amp;#34;apn&amp;#34;: &amp;#34;soracom.io&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;s1.standard&amp;#34;, &amp;#34;groupId&amp;#34;: null, &amp;#34;createdAt&amp;#34;: 1545836470247, &amp;#34;lastModifiedAt&amp;#34;: 1550380631731, &amp;#34;expiredAt&amp;#34;: null, &amp;#34;registeredTime&amp;#34;: 1549618116968, &amp;#34;expiryAction&amp;#34;: null, &amp;#34;terminationEnabled&amp;#34;: false, &amp;#34;status&amp;#34;: &amp;#34;active&amp;#34;, &amp;#34;tags&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;mySim&amp;#34; }, &amp;#34;sessionStatus&amp;#34;: { &amp;#34;lastUpdatedAt&amp;#34;: 1550380631731, &amp;#34;imei&amp;#34;: &amp;#34;353168044272803&amp;#34;, &amp;#34;location&amp;#34;: null, &amp;#34;cell&amp;#34;: { &amp;#34;radioType&amp;#34;: &amp;#34;lte&amp;#34;, &amp;#34;mcc&amp;#34;: 440, &amp;#34;mnc&amp;#34;: 10, &amp;#34;tac&amp;#34;: 12390, &amp;#34;eci&amp;#34;: 185881861 }, &amp;#34;ueIpAddress&amp;#34;: &amp;#34;10.</description>
    </item>
    
    <item>
      <title>「Enkaku」- ロードヒーティング 遠隔操作プロジェクト概要</title>
      <link>https://alltimeneet.com/post/businness-roadheating/</link>
      <pubDate>Sat, 16 Feb 2019 14:29:38 +0900</pubDate>
      
      <guid>https://alltimeneet.com/post/businness-roadheating/</guid>
      <description>リードヒーティング市場について  クソ市場(冬場のみの稼働のため) 上記の市場規模のため大資本・企業が入ってこない。我々が介入する余地が多分に残っている 現状だと、業者などによって人力で行われているらしい。  やること  スマホからのロードヒーティング スイッチを操作のための適切なUI・UXを提供するサービスの開発 サービスをロードヒーティング の会社に営業し導入してもらう。以降サービスの開発運用を行う  サブスクリプション課金モデル
ユーザー及び売上を積み上げる。年単位と言う長いサイクルであるため、解約のハードルはWEBサービスと比較すると高い。    特徴  スタートアップのような派手さ・スケーラビリティは無いが、大きな競合の出現が考えにくく、「解決すべき課題」が明確であるため売上が立つのが早く手堅い。
 と言えると思います
理想  2,3人のチーム 機動力が損なわれるのと、一人当たりのリターンが減少するため。 条件  ハードウェアに知見のあること 開発経験があること(一応個人でも可) 残りの在学期間が長いこと    参考 なぜ大企業はニッチ市場に参入して来ないのか？｜ニッチ市場は中小企業の主戦場</description>
    </item>
    
    <item>
      <title>CircleCIで毎回面倒なHugoのデプロイ作業を自動化する</title>
      <link>https://alltimeneet.com/tech/circleci-hugo/</link>
      <pubDate>Tue, 12 Feb 2019 22:03:25 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/circleci-hugo/</guid>
      <description>CIサービスとは  ビルドとテストを自動化するためのサービス
 ということで理解しておけばいいと思います。一応直訳すると「Continuous Integration（継続的インテグレーションサービス）」、略してCIサービスということらしいです。
参考: なぜCIが必要なのか
目標  GithubPagesで公開しているHugoプロジェクトのデプロイ作業を自動化する
 Hugoの場合はプロジェクト本体ではなく、publicディレクトリ以下をgithubにホスティングする必要があるので、デプロイするときは基本的に以下のような手順を踏まなければならない。
$ git commit -m &amp;#34;hoge&amp;#34; $ hugo #public以下にサイトを生成するコマンド $ cd public $ git commit -m &amp;#34;hogehoge&amp;#34; $ git push このルーティンが段々だるくなってくきたので、CircleCiでこれを自動化する。
手順  レポジトリとデプロイキーを登録する .circleci/config.ymlの記述  参考: CircleCIでHugoを実行してGitHub Pagesにデプロイ
ブログ(HUGO)のビルドとデプロイをCircleCIで自動化した
1. レポジトリとデプロイキーを登録する  レポジトリの登録
最初のブランチ一覧が表示される画面で登録したいレポジトリにチェックマークをつけてFollowを押せば登録できます。 デプロイキーの登録
今回はgithubへのsshキーを登録します。サイドメニューのcheck out SSH Key からadd User KeyでGithubアカウントにログインすること楽に登録ができます。手動で登録も可能ですが、pushのための書き込み権限の付与がされてなくてエラーになりました、何やかんややりましたが解決できなかったので、check out ssh keyからの登録をお勧めします。  2. .circleci/config.ymlの記述 CircleCiにやってほしいことを.circleci/config.ymlに記述します。githubのレポジトリにpushされた時発火します。 僕の場合masterブランチでhugoプロジェクト本体、gh-pagesブランチで公開用のpublic以下のファイル群を管理しています。内容はこんな感じです参考までに
version: 2 jobs: build: docker: - image: cibuilds/hugo:latest environment: TZ: Asia/Tokyo #ここら辺はコピペでいいと思う branches: ignore: - gh-pages #gh-pagesにプッシュされた際に反応しないようにignoreを設定している steps: - checkout - run: name: &amp;#34;Setting for Git&amp;#34; command: | git config --global user.</description>
    </item>
    
    <item>
      <title>ブログをJekyllからHugoへ移行した</title>
      <link>https://alltimeneet.com/tech/hugo-import-jekyll/</link>
      <pubDate>Tue, 12 Feb 2019 22:01:43 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/hugo-import-jekyll/</guid>
      <description>データをJekyllからインポート なんとHugoがコマンドを用意してくれています。一発で綺麗に引越し完了！とはなりませんが、楽チン。
$ hugo imoprt jekyll path_to_jekyll_root_project path_to_hugo_root_project 日付のデータは、移行できないようです。なぜか記事ファイルのメタデータが無視されていたので、手動でコピーし直しました。 終了すると、Hugoから
$ git clone https://github.com/spf13/herring-cove.git HOGEHOGE/themes/herring-cove $ hugo server --theme=herring-cove 「このコマンド打ってな〜」と言われると思いますが、なんとその通りにやってもうまくいきません！笑 git cloneしたherring-coveテーマが原因です。おそらくアプデされていないのでしょう。以下のように直します。変更箇所は複数のファイルで存在するので、エディタの機能使うなどして一括変換するといいと思います。
 {{ template &amp;ldquo;theme/herring-cove/footer.html&amp;rdquo; . }} を {{ partial &amp;ldquo;footer.html&amp;rdquo; }}に {{ template &amp;ldquo;theme/herring-cove/header.html&amp;rdquo; . }} を {{ partial &amp;ldquo;header.html&amp;rdquo; }}に  これで再度hugo serverすると動いてくれるかなと思います。正常に動くのを確認したら、あとは適当に良さげなテーマ選んでやればおkです！
終わりに 日付のデータを移行できなかったのが残念ですね。。それ以外は簡単に移行できたので、まぁ良しとします！
「ブログを書く→git commit→git push」という手順を踏むのが面倒になってきたので 次回は流行り？のCIサービス、CircleCIの無料枠を使ってデプロイの自動化を行いたいと思います。こちらもこのブログで手順や所感をメモしておこうとお思います。</description>
    </item>
    
    <item>
      <title>Hugo覚書とその所感</title>
      <link>https://alltimeneet.com/tech/2019-01-20-programming-hugo/</link>
      <pubDate>Sun, 20 Jan 2019 09:03:48 +0900</pubDate>
      
      <guid>https://alltimeneet.com/tech/2019-01-20-programming-hugo/</guid>
      <description>ざっくりHugoについて Go製の静的webジェネレータ。新しいライブラリというかフレームワーク？？なので、コミュニティもJekyllに比べて盛んな印象です。
インストール $ brew install hugo $ hugo version brew以外のインストール方法もあるようです。 参考: install Hugo
使い方 コマンド  プロジェクト作成  $ hugo new site yoursite  ローカルサーバーを立てる  $ hugo server  post  $ hugo new post/first-post.md /content以下に作成される仕様になっております。
 テーマの適用  $ git clone hoge@hoge.git themes/hoge #テーマ「hoge」をclone $ echo &amp;#39;theme = &amp;#34;hoge&amp;#34;&amp;#39; &amp;gt;&amp;gt; config.toml #config.tomlへ記述 設定などはconfig.tomlへ記述するようです。どうでもいいけど、toml形式って初めて見ました。 こちらの公式ドキュメントが参考になると思います quickstart
HugoでGithubPagesにホスティング $ hugo でpublicディレクトリが追加される。 このpublicディレクトリ以下をGithubPagesでホスティングします。プロジェクトディレクトリではありません、注意！
やっておくと良いこと  絶対パス化  $ echo &amp;#39;canonifyurls = true&amp;#39; &amp;gt;&amp;gt; config.</description>
    </item>
    
    <item>
      <title>RaspberryPIとSoracomAirのSimを使って通信してみる</title>
      <link>https://alltimeneet.com/post/2019-01-11-raspberrypi-communication-test/</link>
      <pubDate>Mon, 14 Jan 2019 09:03:48 +0900</pubDate>
      
      <guid>https://alltimeneet.com/post/2019-01-11-raspberrypi-communication-test/</guid>
      <description>ロードヒーティングのOn/Off切り替えが面倒なので、スマホから操作したいプロジェクトの実現に向けて、まずはRasPiとSoracomAirで通信できるか試してみる。
目標  RasPiで通信する
 用意したもの  RaspberryPI ZERO WH  Amazon Basis miniHDMI-HDMIケーブル  USB変換アダプタ  SDカード(8GB以上必要)  やること  OSインストール wvdialで通信  OSインストール フォーマット まずはじめにSDカードのフォーマットを行なっておきましょう。RaspberryPiが読み込めるフォーマット(FAT32)にしておく必要があります。よくわからないという方はSDCardFormatterというソフトでフォーマットしておけばおkです。Raspbianのインストールには4GB以上必要なので注意です。(一敗)
インストール RaspberryPiにraspbianというOSをインストールします。
 こちらのリンクからダウンロードして解凍したファイル群をSDカードのルートにコピー  SDカードをRaspberryPiに挿入し、電源コードを接続すると起動するはずです メニューが表示されるのでRasbianをenter選択し、「i」を押すとインストールが始まります。  通信してみる 1.USBデバイスの確認 $ lsusb としてUSB機器として認識しているかをまず確認します。「LG Electronics, Inc. Ally/Optimus One」という名称でした。 2.確認できたら、ttyデバイスとして認識させます。 sudo modprobe usbserial vendor=VENDORID product=PRODUCTID 3.必要なソフトのインストールと設定 sudo apt-get install wvdial sudo vi /etc/wvdial.conf 内容は以下です。コピペでおk。
[Dialer Defaults]Init1 = ATZInit2 = ATQ0 V1 E1 S0=0 &amp;amp;C1 &amp;amp;D2 +FCLASS=0Init3 = AT+CGDCONT=1,&amp;#34;IP&amp;#34;,&amp;#34;soracom.</description>
    </item>
    
    <item>
      <title>Fish Shell覚書</title>
      <link>https://alltimeneet.com/post/2019-01-11-fish-shell/</link>
      <pubDate>Sat, 12 Jan 2019 09:03:48 +0900</pubDate>
      
      <guid>https://alltimeneet.com/post/2019-01-11-fish-shell/</guid>
      <description>導入&amp;amp;設定 導入 $brew install fish デフォルトシェルに設定
$ sudo vi /etc/shells #以下を記述 /usr/local/bin/fish $chsh -s /usr/local/bin/fish 設定 設定やpathはconfig.fishに記述
$ vi ~/.config/fish/config.fish 読み込み
$ source ~/.config/fish/config.fish その他 rbenv rubyのバージョン管理のライブラリで使用している方も多いと思われる。fishだとそのままでは動かないので以下のように記述する
rbenv init - | source GOPath set -x GOPATH /users/username/go set -x PATH $PATH /usr/local/go/bin $GOPATH/bin 参考  【fish shellでモダンなターミナル環境を構築】＠2017年版 fish で rbenv の初期処理を実行する方法  </description>
    </item>
    
    <item>
      <title>ロードヒーティングのスイッチをスマホから遠隔操作するプロジェクト</title>
      <link>https://alltimeneet.com/post/2019-01-05-programming-roadheating/</link>
      <pubDate>Sat, 05 Jan 2019 09:03:48 +0900</pubDate>
      
      <guid>https://alltimeneet.com/post/2019-01-05-programming-roadheating/</guid>
      <description>趣旨  下記の問題を、ロードヒーティングのOn/Offをスマホから操作できるようにすることで解決したい。
 経緯 僕が住む北海道などの積雪地方ではロードヒーティングという設備が利用されている。本州在住の方には馴染みがないかもしれないがこの装置は、文字通り床を温めて雪を溶かしてくれるものだ。
このロードヒーティングを稼働させるには「自動」と「手動」の2タイプが存在するのだが、「自動」の場合稼働させるとアイドリングで結構電気代を持っていかれるし雨と雪を勘違いする誤動作も多いためコスパが悪い。そのため我が家では「手動」で行っている。 「手動」で稼働させた場合スイッチは物理的に切り替えなければならないため、外出時に突然雪が降ってきて家のロードヒーティングのスイッチを入れておくみたいなことはできない。 これが自分の家だけではまだいいのだが、両親が他に所有している近くのアパートも同じ仕組みで動いておりわざわざアパートまで出向きスイッチを入れなければならず、この点が非常にネックになっている。というか非常に面倒臭い。この問題をRaspberryPiを用いてスマホから操作できるようにすることで解決できないかと思い、考えてみた。
必要なもの 注）商品のリンクはAMAZONですが、金額は実際に購入した金額です。買えるものはメルカリで買っているので、リンク先の値段と表の値段が異なる場合があります。
   品目 説明 値段     soracom airカード ネットとの通信に必要。IoT用のものを使用。 1200円   usbドングル RasPiとSimを接続するためのもの。DOCOMO L-02C 1680円   Raspberry Pi WH 基盤（PCで言う所のマザーボードのようなもの）&amp;amp;CPU 1800円   SwitchBot RaspberryPiと繋いでスイッチングできるモジュール &amp;mdash;   sdカード Raspiに刺してOSをインストールするもの すでに持っている   RasPi用電源コード スマホのような充電方法だと、電力不足になるらしい &amp;mdash;    Rasberry Piの種類について簡単なメモ 標準サイズ  Raspberry Pi 3 CPU 64bit。WifiとBluetoothが標準搭載。 Raspberry Pi 2 Model B RasPi 3に次ぐスペック。  小型版  Raspberry Pi Zero 初心者用のシンプルなモデル。5$と非常に安価。 Raspberry Pi Zero W RasPi ZeroにWifiとBluetoothが標準搭載されたモデル。 Raspberry Pi Zero WH Raspberry Pi Zero Wにピンヘッダを実装したもの。今回はこれを実験用として使う。  エクステンション  3GPi simスロットが搭載されている。RasPi3と組み合わせて使用する。2万円代と少し値段が高い・・・  参考: 購入可能なラズパイ比較(2018年5月)Pi 3 Model B/Pi Zero/Pi Zero W/Pi2 Model B/Pi Model B+</description>
    </item>
    
    <item>
      <title>TOC(Table Of Contents)を自動生成する</title>
      <link>https://alltimeneet.com/post/2019-01-04-auto-create-markdown-toc/</link>
      <pubDate>Fri, 04 Jan 2019 09:03:48 +0900</pubDate>
      
      <guid>https://alltimeneet.com/post/2019-01-04-auto-create-markdown-toc/</guid>
      <description>普段はMarkdown方式で記事を書いている僕。基本的に[TOC]とすることで目次を自動生成してくれるのだが、GithubMarkdownはなぜか対応していない。何かいい方法はないかとググってみたら**github-markdown-toc.go**なるツールを見つけた。自動生成できるようなので紹介と使い方のメモ。
インストール brew install github-markdown-toc 使い方 こちらに説明があるのだが、一応メモ。
まとめ 記事のページにこういう目次があることによってSEO対策にもなるし、読者にとっても読みやすくなるのでこういうツールがあると助かります。</description>
    </item>
    
    <item>
      <title>GithubPagesのサイトで、Twitterカードの画像だけが反映されない</title>
      <link>https://alltimeneet.com/post/2018-12-30-fix-twittercards-image/</link>
      <pubDate>Sun, 30 Dec 2018 09:03:48 +0900</pubDate>
      
      <guid>https://alltimeneet.com/post/2018-12-30-fix-twittercards-image/</guid>
      <description> 適当に調べたところ、このような記事を発見。参考にしたら治りました。 Twitterカードの設定は正しいのに画像が表示されない原因
やったこと &amp;lt;meta name=&amp;#34;twitter:image&amp;#34; content=&amp;#34;https://raw.githubusercontent.com/myusername/blog/master/images/thumbs/{{ page.image }}&amp;#34; /&amp;gt; のようにカスタムドメインではなく、githubcontent.comのURLで指定するとうまくいきました。
おまけ 参考にしてくださいmm
 ツイッターカードのメタデータ一覧  引用: ツイートにページ情報を表示する「Twitterカード（Twitter Cards）」を設定してみた  </description>
    </item>
    
    <item>
      <title>SwiftでEnumのおさらい</title>
      <link>https://alltimeneet.com/post/2018-12-29-swift-enum/</link>
      <pubDate>Sat, 29 Dec 2018 09:03:48 +0900</pubDate>
      
      <guid>https://alltimeneet.com/post/2018-12-29-swift-enum/</guid>
      <description> 要素数の取得  CaseIterableプロトコルの準拠(Swift4.2~)  Enum.allCases.count 値の取得・逆引き 値型Enumの時はrawValueを用いて取得可能
 取得  Enum.case.rawValue  値から逆引き  Enum(rawValue: value) ちなみに値を指定しなかった時はかたによって以下のように振る舞いが変わります
 String型のとき caseの名前がそのまま値になる Int型のとき 0から順に番号が振られる  </description>
    </item>
    
  </channel>
</rss>